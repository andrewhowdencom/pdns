= pDNS
:icons: font

- [P]roxy 
- [D]omain 
- [N]ame 
- [S]erver

TIP: This is an implementation of the N26 SRE challenge.

== Justification

This project is a DNS proxy. It functions as an intermediary layer converting applications that speak DNS over TCP
on the listening interface and forwards to a DNS over HTTPS upstream resolver.

== Usage

=== Starting the daemon

The daemon can be started as follows:

[source,bash]
----
$ pdns
----

It is then possible to query the daemon with the `dig` utility as follows:

[source,bash]
----
dig +tcp andrewhowden.com @127.0.0.1 +short
----

== Development

=== Task Runner

This project makes heavy use of the drone.io docker based pipeline tooling. More can be found at the URL:

- https://drone.io/

To install drone on a local machine see:

- https://docs.drone.io/cli/install/

The following are the tasks that are supported locally:

|===
| Task                                                          | Result

| `drone exec --pipeline=lint`                                  | Static analysis tools in the project
| `drone exec --pipeline=test`                                  | Go unit tests
| `drone exec --env-file .env --pipeline=container --trusted`   | Build the container image
|===

==== nsenter: failed to unshare namespaces: Operation not permitted

To execute the `img` container builder binary locally unprivileged user namespace cloning needs to be enabled. To do 
so, execute:

[source,bash]
----
echo 1 | sudo tee /proc/sys/kernel/unprivileged_userns_clone
----

In principle this is a harmless change, however there have been issues associated with unprivileged user namespace sharing
in the past⁴

== Git Hooks

To use the git hooks that this project expects, run the following command within the project:

[source,bash]
----
$ git config core.hooksPath $(git rev-parse --show-toplevel)/bin
----

== Minimum Viable Product (MVP)

=== Application [×]

To have this project considered "initially complete" the project is expected to be able to fulfil a local DNS request 
over TCP and proxy that request to a given DNS over TLS upstream.

[ditaa]
....
+-----------------+                   +------------------+              +---------------------+
|                 |                   |                  |              |                     |
|  Client App     +-----DNS / TCP-----+        pDNS      +--DNS / TLS---+    CloudFlare       |
|                 |                   |                  |              |                     |
+-----------------+                   +------------------+              +---------------------+
....

=== Dockerfile [×]

The application should be packed into a Dockerfile

=== Documentation [x]

Documentation attached to this project should include:

- Security concerns of this application in infrastructure
- How this application should be deployed in a distributed, microservice architecture
  & containerized architecture (potentially with several options)
- Further improvements that would be interesting for this project

== Roadmap

Recommended

- [×] The abilility to handle multiple, parallel requests
- [×] A UDP listener

Additional

- [×] Configurable application parameters (upstream nameserver, listen port, listen host)
- [×] A caching layer for the DNS responses
- [×] Multiple upstream protocols (DNS over TLS, DNS over HTTPS, DNS over UDP)

== Design

CAUTION: The following design is only the broad strokes of the project. More specific design choices associated
         with given packages, tooling or other minutiae are part of the commit log. These are visible by running
	    `git log path/to/file`

=== Project Layout

This project follows the pattern of an "all aspects of a service in one place" type design. This has worked well in
the past with cross functional teams and a high level of service ownership. See the following link for details:

- https://l.littleman.co/2V6F6ns

=== Language Choice: Go

The project requirements were open to any given language but the langauge chosen for this project was Go. This is not
the authors most familiar language, however Go has a number of characteristics that make it uniquely suitable for a
task such as this:

- Simple deployment model being a statically compiled binary
- Excellent networking libraries
- A concurrency model that should allow parallelizing requests easily
- A (relatively) small memory and compute overhead for the daemon

=== Dockerfile: Multistage, scratch

The dockerfile is a "two stage". 

==== Stage 0

Stage 0 is a Debian Buster image that:

- Contains a set of certificate authorities that are trusted by the Debian maintainers
- Contains the go runtime

The binary is compiled within this image statically

==== Stage 1

Stage 1 is "scratch" or empty image into which the certificates and the binary are copied.

Such an image has some interesting benefits:

- It is small and can be shipped across the network quickly
- There is almost no attack surface in shared libraries that might be consumed by the go binary or in processes that
  could be executed in the case there was a remote code execution.

Practically the filesystem layout looks like:

[source,bash]
----
.
├── pdns
├── etc
│   └── ssl
│       └── certs
│           ├── 02265526.0 -> Entrust_Root_Certification_Authority_-_G2.pem
│           ├── 03179a64.0 -> Staat_der_Nederlanden_EV_Root_CA.pem
│           ├── 062cdee6.0 -> GlobalSign_Root_CA_-_R3.pem
... (and so on)
----

=== CI/CD: Drone

Projects tend to benefit an extraordinarily large amount by shifting conversations associated with code style, test
coverage, linting and other project quality controls to a service that renders a binary "yes/no" decision. Further,
the development team will buy into the findings of this service much more if they are responsible for building and
understanding that service.

Further, that same service can be used to propagate changes into production based on particular version control events,
time based events or other tooling.

The "drone.io" CI/CD service is a minimal, docker based implementation of CI that allows writing very flexible and
reasonably complex pipelines but does not reinvent primitives beyond what it needs to (for example, authentication).

It has the tremendous advantage for this project that it can be executed locally, without any upstream server. This
allows it to be integrated in with git hooks, as well as some demonstration of how a conceptual CI pipeline would
look like.

== Review

The reviewers of this project are encouraged to review the git histories for a more detailed discussion as to how
a given design decision was made. The project has been recorded such that it should be possible to see the
evolution of a project by running:

[source,bash]
----
git log --reverse --patch
----

== References

1. CloudFlare, "DNS over TLS", https://developers.cloudflare.com/1.1.1.1/dns-over-tls/, Accessed Sep-2019.
2. P. Mockapetris, "Domain Names - Implementation and Specification", https://tools.ietf.org/html/rfc1035#section-4.2.2, Accessed Sep-2019
3. Wikpedia, "DNS over TLS", https://en.wikipedia.org/wiki/DNS_over_TLS, Accessed Sep-2019
4. Forest, "What does enabling unpriviged userns clone do", https://security.stackexchange.com/a/209533, Accessed Sep-2019